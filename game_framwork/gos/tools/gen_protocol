#!/usr/bin/env ruby

require "yaml"

source = "./src/config/protocol.yml"
target = "./src/app/consts/protocol.go"

defines = YAML.load_file(source)

COMMON_TYPE = ['bool', 'byte', 'string', 
               'uint16', 'uint24', 'uint32', 'uint64', 
               'int16', 'int24', 'int32', 'int64',
               'float32', 'float64']
PROTOCOL_TYPE = defines.keys

#
# Generate protocol structs
#
File.open(target, "w") do |io|
  io.write "//Generated by tools/gen_protocol\n"
  io.write "package consts\n"
  defines.each do |key, field_defines|
    fields = []
    field_defines.each do |field, type|
      if type.index("array-") == 0
        sub_type = type.split('-')[1]
        if PROTOCOL_TYPE.include?(sub_type)
          fields << "#{field} []*#{sub_type}"
        else
          fields << "#{field} []#{sub_type}"
        end
      else
        fields << "#{field} #{type}"
      end
    end
    io.write %Q{
type #{key} struct {
    #{fields.join("\n    ")}
}
}
  end
end


#
# Generate api decoder
#
target = "./src/api/decoder.go"

def common_protocol(field_type, variable, code)
  if code == "write"
    "buffer.Write#{field_type.capitalize}(v.#{variable})"
  elsif code == "read"
    "data.#{variable} = buffer.Read#{field_type.capitalize}()"
  else
    assert(false, "Invalid code!")
  end
end

header = %Q{\
/*
 * Generated by tools/gen_protocol
 */
}

encode_handlers = []
decode_handlers = []

defines.each do |protocol, define|
  encode_fields = []
  decode_fields = []
  define.each do |field, type|
    if COMMON_TYPE.include?(type)
      decode_fields << common_protocol(type, field, "read")
      encode_fields << common_protocol(type, field, "write")
    elsif PROTOCOL_TYPE.include?(type)
      decode_fields << %Q{data.#{field} = encode#{type}(buffer)}
      encode_fields << %Q{encode#{type}(buffer, v.#{field})}
    elsif type.index("array-") == 0
      sub_type = type.split('-')[1]
      if COMMON_TYPE.include?(sub_type)
        decode_fields << %Q{
    for i := 0; i < int(buffer.ReadUint16()); i++ {
        data.#{field} = append(data.#{field}, buffer.Read#{sub_type.capitalize}())
    }}
        encode_fields << %Q{
    buffer.WriteUint16(uint16(len(v.#{field})))
    for i := 0; i < len(v.#{field}); i++ {
        buffer.Write#{sub_type.capitalize}(v.#{field}[i])
    }}
      else
        decode_fields << %Q{
    for i := 0; i < int(buffer.ReadUint16()); i++ {
        data.#{field} = append(data.#{field}, decode#{sub_type}(buffer).(*#{sub_type}))
    }}
        encode_fields << %Q{
    buffer.WriteUint16(uint16(len(v.#{field})))
    for i := 0; i < len(v.#{field}); i++ {
        encode#{sub_type}(buffer, v.#{field}[i])
    }}
      end
    end
  end
  decode_handlers << %Q{
func decode#{protocol}(buffer *packet.Packet) interface{} {
    data := &#{protocol}{}
    #{decode_fields.join("\n    ")}
    return data
}}
  encode_handlers << %Q{
func encode#{protocol}(buffer *packet.Packet, value interface{}) {
    v := value.(*#{protocol})
    #{encode_fields.join("\n    ")}
}}
end

#
# Generate api decoder
#
File.open(target, "w") do |io|
  io.write %Q{\
#{header}
package api

import (
	. "app/consts"
	"gslib/utils/packet"
)

#{decode_handlers.join("\n")}

type DecodeHandler func(buffer *packet.Packet) interface{}

var decode_handlers = map[string]DecodeHandler{
    #{defines.keys.map{|protocol| "\"#{protocol}\": decode#{protocol}"}.join(",\n    ")}}

func Decode(decode_method string, buffer *packet.Packet) interface{} {
	if handler, ok := decode_handlers[decode_method]; ok {
		return handler(buffer)
	} else {
		return nil
	}
}
}
end

#
# Generate api encoder
#
target = "./src/api/encoder.go"
File.open(target, "w") do |io|
  io.write %Q{\
#{header}
package api

import (
	  . "app/consts"
	  "gslib/utils/packet"
)

#{encode_handlers.join("\n")}

type EncodeHandler func(buffer *packet.Packet, value interface{})
var encode_handlers = map[string]EncodeHandler{
    #{defines.keys.map{|protocol| "\"#{protocol}\": encode#{protocol}"}.join(",\n    ")}}

func Encode(encode_method string, v interface{}) *packet.Packet {
    protocol := NameToId[encode_method]
    buffer := packet.Writer()
    buffer.WriteUint16(protocol)
	  encode_handlers[encode_method](buffer, v)
    return buffer
}
}
end

#
# Generate api map
#
target = "./src/api/api_map.go"
File.open(target, "w") do |io|
  name_to_id = []
  id_to_name = []
  defines.keys.each_with_index do |name, idx|
    name_to_id << %Q{"#{name}": uint16(#{idx + 1})}
    id_to_name << %Q{uint16(#{idx + 1}): "#{name}"}
  end
  io.write %Q{\
#{header}
package api

var NameToId = map[string]uint16{
    #{name_to_id.join(",\n    ")}}

var IdToName = map[uint16]string{
    #{id_to_name.join(",\n    ")}}
}
end
